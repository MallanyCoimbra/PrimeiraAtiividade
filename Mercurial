  Mercurial 

Mercurial é uma ferramenta multi-plataforma de controle de versão distribuído para desenvolvedores de software. O sistema é implementado principalmente em Python, porém o utilitário binário diff foi escrito em C. Mercurial foi inicialmente escrito para rodar sobre Linux, mas foi portado para Windows, Mac OS X, e a maioria dos outros sistemas UNIX. Mercurial é principalmente um programa de linha de comando. Todas operações do Mercurial são chamadas através de palavras chave de opções para o programa controlador hg, uma referência para o símbolo químico do elemento Mercúrio.

Instalando o Mercurial

Linux
Para ter o mercurial instalado em seu linux basta utilizar o gerenciador de pacotes de sua distribuição e instalar o pacote mercurial. Para a utilização a partir do Eclipse pode ser necessária a instalação de um pacote que permita ao seu ambiente solicitar a senha. O pacote ssh-askpass-gnome, ou apenas ssh-askpass caso não utilize o gnome, podem ser utilizados.
Os nomes aqui utilizados estão presentes na última release do Debian, talvez ocorram pequenas alterações no nome para a sua distribuição.

Clonando um repositório:
O seguinte comando irá clonar fielmente o repositório na máquina local, é aconselhável não utilizar este repositório para trabalhar.
$ hg clone http://hg.code.sf.net/p/adempiere/localization-br adempierelbr
Se visualizarmos o diretório adempierelbr, perceberemos que dentro dele tem apenas um subdiretório ".hg"... é neste subdiretório que está todo o conteúdo do repositório. Os arquivos de trabalho serão gravados no diretório adempierelbr... mas como utilizaremos este apenas como clone do original, aqui ele vai ficar intocado. Nas partes seguintes deste guia, para padronizar e deixar mais claro o entendimento, este repositório local será referenciado como repostório local de referência, e o repositório remoto do projeto, será sempre referenciado como repositório remoto.

 - Clonando o clone
Para trabalharmos utilizaremos um outro clone, como cada clone é um repositório completo, basta ir um nível antes do clone feito no item anterior, e cloná-lo novamente:
$ hg clone adempierelbr lbrwork
Pronto... agora a pasta lbrwork é um clone do clone, deve-se preferir trabalhar dentro desta pasta. Igualmente aos outros repositórios, todas as referências posteriores a este serão identificadas como repositório de trabalho.

Escolhendo a branch de origem:
Ao trabalhar com o localization_br, todo o desenvolvimento deve ter por base a branch "development", portanto, precisamos "selecionar" esta branch como sendo a nossa origem, deve-se entrar no diretório de trabalho "lbrwork" e rodar o comando "hg update"
$ cd lbrwork
$ hg update development
Após este comando, os arquivos do repositório ".hg" serão copiados para o diretório lbrwork, e já podem ser editados livremente, porém, é aconselhável iniciar uma branch para este trabalho, isto permite isolar cada desenvolvimento um do outro.
Os arquivos e diretórios gravados diretamente dentro da pasta lbrwork, será sempre referenciado como diretório de trabalho. Atenção, não confundir com repositório de trabalho, já citado anteriormente, que é todo o repositório, contido dentro da pasta .hg.

- Criando uma branch
Criar uma branch é simples... basta digitar o seguinte comando:
$ hg branch fulano
A partir deste ponto, seu repositório tem uma branch chamada fulano. É aconselhável nunca editar diretamente os branches stable e development do localization_br, estas branches devem apenas receber merge das branches dos desenvolvedores, de acordo com o Guia de desenvolvimento.

Colocando as mãos na massa
Este é o ponto onde você apenas precisa cuidar do código, programar mesmo, aquele que é o nosso objetivo! É só apontar o seu editor ou interface preferida para os arquivos do diretório de trabalho e fazer as coisas evoluírem.

Adicionando arquivos
Por default, qualquer arquivo novo criado no diretório de trabalho não será adicionado ao repositório de trabalho. Para avisar o Mercurial que um arquivo deve fazer parte dele, utiliza-se o comando "add":
$ hg add nomedoarquivo.ext
Caso o comando seja executado sem fornecer um nome de arquivo, todos os arquivos do diretório serão adicionados ao repositório de trabalho.

A hora do commit
Após editar o código, testar, debugar, corrigir, testar de novo e ver que deu certo, chegou a hora de dar o commit... o comando para isso é o seguinte:
$ hg commit
Mas, espere um pouco... este comando apenas pega os arquivos do diretório de trabalho e coloca no diretório ".hg", que é o repositório de trabalho. Para publicar de verdade este trabalho, é preciso fazer um "push". É isso mesmo, o push é o novo commit:
$ hg push --new-branch https://fulano@hg.code.sf.net/p/adempiere/localization-br
Lógico que "fulano" deve ser substituído pelo seu nome de usuário no sf.net, e a sua senha será solicitada.
O parâmetro --new-branch é necessário pois por padrão o Mercurial se recusa a publicar novas branches, é uma medida de segurança.
Caso o último parâmetro, que é o endereço de escrita do repositório não seja fornecido, ele irá atualizar o repositório de onde foi feito o clone. Como este é o repositório de trabalho, que foi "clonado do clone", executar o push sem parâmetro, apenas atualizaria o repositório local de referência na máquina local... o que também pode ser feito, para manter as coisas sincronizadas.

Atualizando o repositório
Com alguma frequência é necessário que atualizemos o nosso repositório de trabalho para receber as mais novas atualizações dos desenvolvedores, para isto existe o comando "pull":
$ hg pull 
Como já vimos antes, isto vai trazer as alterações a partir da origem do repositório atual, que, no caso do repositório de trabalho é o repositório local de referência. Portanto, neste exemplo, a melhor sequência de comandos é a seguinte:
$ cd ../adempierelbr
$ hg pull
$ cd ../lbrwork
$ hg pull

Alternando entre branches
Aqui aparece uma das maravilhas do Mercurial: É possível alternar entre uma branch e outra!
No momento em que executamos o comando "update" no tópico que escolheu a branch de origem, o nosso diretório de trabalho passou a ter os arquivos da branch "development". E, após a execução do comando que criou a branch "fulano", tais arquivos passaram a fazer parte desta branch.
O comando "update" faz exatamente isso, altera os arquivos do diretório de trabalho para que reflitam a branch referida. O comando update não vive só de branches, é possível alternar para qualquer ponto do repositório, uma revisão, changeset, tag ou branch.
Sempre antes de executar o comando "update", certifique-se de que todas as alterações efetuadas no diretório de trabalho foram salvas no repositório de trabalho através do comando "commit".
O seguinte exemplo alterna o diretório de trabalho para a branch "stable":

